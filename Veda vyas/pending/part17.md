
1. [ ] **Cluster vs Child Process** → Difference between cluster and child_process modules in Node.js. ✅ 2025-09-12

2. [ ] **Child Process Use Cases** → When to use child_process instead of cluster in Node.js. ✅ 2025-09-12

3. [ ] **Child Process Example** → Example of running a child process in Node.js. ✅ 2025-09-12

4. [ ] **Cluster vs Child Process Summary** → Summary difference between cluster and child_process in terms of port sharing and typical use cases. ✅ 2025-09-12

5. [ ] **PM2 Scaling** → How to scale an application using PM2 process manager. ✅ 2025-09-12

6. [ ] **PM2 Monitoring** → How to monitor logs and processes with PM2. ✅ 2025-09-12

7. [ ] **Node.js Thread Pool** → What Node.js thread pool is and what operations use it. ✅ 2025-09-12

8. [ ] **Thread Pool Size** → Default thread pool size and how to change it in Node.js. ✅ 2025-09-12

9. [ ] **Thread Pool Tasks** → What kinds of asynchronous tasks are executed in the thread pool. ✅ 2025-09-12

10. [ ] **Non-Thread Pool Tasks** → What asynchronous tasks do NOT use the thread pool in Node.js. ✅ 2025-09-12

11. [ ] **Cluster Core Detection** → How Node.js cluster module determines how many cores to use. ✅ 2025-09-12

12. [ ] **Worker Thread Pool** → Whether each cluster worker gets its own thread pool. ✅ 2025-09-12

13. [ ] **Worker Threads vs Thread Pool** → Difference between worker_threads and the libuv thread pool. ✅ 2025-09-12

14. [ ] **Heavy JS Computation** → Which to use for heavy JS computation: worker_threads or thread pool. ✅ 2025-09-12

15. [ ] **Shared Memory** → What shared memory is and whether worker_threads allow for shared memory. ✅ 2025-09-12

16. [ ] **Concurrency Model Workflow** → When to use worker_threads, thread pool, cluster, or child_process in different workflows. ✅ 2025-09-12

17. [ ] **Production Concurrency Models** → How parallel/concurrent models interact in a production Node.js deployment. ✅ 2025-09-12

18. [ ] **PM2 in Production** → Role of PM2 in a Node.js production architecture. ✅ 2025-09-12

19. [ ] **Nginx in Scalable Backend** → How Nginx fits into a scalable Node.js backend architecture. ✅ 2025-09-12

20. [ ] **Nginx Configuration** → What a typical Nginx config looks like for proxying to a Node.js app. ✅ 2025-09-12

21. [ ] **Production Request Flow** → Flow of a typical production request from user to backend (user → NGINX → PM2/Cluster → Node Worker → thread pool/worker thread/child process). ✅ 2025-09-12

22. [ ] **Docker vs Kubernetes** → When to use Docker and when to use Kubernetes. ✅ 2025-09-12

23. [ ] **Kubernetes Ingress Traffic** → What Ingress traffic is in Kubernetes terminology. ✅ 2025-09-12

24. [ ] **SSL with Nginx** → How to set up SSL with Nginx for a Node.js application. ✅ 2025-09-12

25. [ ] **End-to-End Workflow** → What an end-to-end (upload, process, serve) workflow looks like using all these tools. ✅ 2025-09-12

26. [ ] **Video/Image Processing** → How to handle video/image processing and which Node.js concurrency model to use. ✅ 2025-09-12

27. [ ] **CPU-Intensive Endpoints** → How to scale Node.js for very CPU-intensive HTTP endpoints. ✅ 2025-09-12

28. [ ] **Blocking Request Prevention** → How to avoid a single slow request blocking everything else in Node.js. ✅ 2025-09-12

29. [ ] **PM2 vs Manual Clustering** → When to prefer PM2 clustering over manual cluster setup. ✅ 2025-09-12

30. [ ] **Mixed Concurrency Models** → Whether you can mix and match cluster, worker_threads, and child_process in large applications. ✅ 2025-09-12

31. [ ] **PM2 Log Management** → How logs and restarts are managed in a PM2-based deployment. ✅ 2025-09-12

32. [ ] **Nginx SSL Termination** → How Nginx handles SSL termination for Node.js backend. ✅ 2025-09-12

33. [ ] **Reverse Proxy in Production** → How to use a reverse proxy with Node.js in production. ✅ 2025-09-12

34. [ ] **High-Performance Backend** → How worker_threads, child_process, cluster, PM2, and Nginx work together in a high-performance, scalable backend. ✅ 2025-09-12

35. [ ] **Token Authentication Frontend** → How to handle token-based authentication in the frontend (localStorage vs HttpOnly cookie). ✅ 2025-09-12

36. [ ] **Token Storage Pros/Cons** → Pros and cons of each approach for keeping tokens in the frontend. ✅ 2025-09-12

37. [ ] **Manual Worker Thread Pool** → Whether we need to manually implement a worker thread pool in Node.js. ✅ 2025-09-12

38. [ ] **Service Workers** → What Service Workers are and how they work in web applications. ✅ 2025-09-12

39. [ ] **Worker Threads in Node.js** → What Worker Threads are in Node.js and when to use them. ✅ 2025-09-12

40. [ ] **Web Workers vs Node Workers** → What Web Workers are in the browser and how they differ from Node.js workers. ✅ 2025-09-12

41. [ ] **Clinic.js Profiling** → What Clinic.js is and how it's used for performance profiling in Node.js. ✅ 2025-09-12

42. [ ] **Optional React Libraries** → Popular optional React libraries and their use cases. ✅ 2025-09-12

43. [x] **Virtual DOM & Diffing** → Understanding Virtual DOM and the diffing algorithm in React. ✅ 2025-09-12

44. [x] **Components & JSX** → Understanding React components and JSX syntax. ✅ 2025-09-12

45. [x] **State vs Props** → Difference between state and props in React components. ✅ 2025-09-12

46. [x] **Class vs Functional Components** → Difference between class and functional components in React. ✅ 2025-09-12

47. [x] **React Fragment & Keys** → Understanding React Fragment and Keys for list rendering. ✅ 2025-09-12

48. [x] **useState & useEffect** → Understanding useState and useEffect hooks with cleanup functions. ✅ 2025-09-12

49. [x] **useContext & Context API** → Understanding useContext hook and Context API for state management. ✅ 2025-09-12

50. [x] **useRef & useImperativeHandle** → Understanding useRef and useImperativeHandle hooks for DOM manipulation. ✅ 2025-09-12